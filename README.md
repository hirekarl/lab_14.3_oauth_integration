# Lab 14.3: OAuth Integration

[Karl Johnson](https://github.com/hirekarl)  
2025-RTT-30  
<time datetime="2025-08-29">2025-08-29</time>

## Assignment
This lab is a reading and reflection exercise. There is no coding involved. Your task is to carefully read the following article on real-world OAuth vulnerabilities and then answer the reflection questions in a written document.

### Task 1: Reading Assignment
Please read the following article from Doyensec’s blog. It provides a detailed overview of common OAuth flows and, more importantly, common attacks against those flows.

- [**Article**: Common OAuth Vulnerabilities ](https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html)

Focus on understanding not just what the attacks are, but how they exploit misconfigurations or weaknesses in an OAuth implementation.

### Task 2: Written Reflection
After reading the article, answer the following questions in a clear and concise manner. Your total response should be between 300 and 500 words.

#### 1. CSRF and the `state` Parameter
In your own words, explain how an attacker could perform a Cross-Site Request Forgery (CSRF) attack on an OAuth flow. How does using the `state` parameter, as recommended, prevent this specific attack?
> In a Cross-Site Request Forgery attack, an attacking agent tricks the victim into interacting with a client application using the attacker's authorization context instead of their own. An attacker logs in to the third-party authentication service (e.g., GitHub) and gets back a valid authorization code. With that valid auth code in hand, the attacker makes a malicious link that includes the valid auth code, and tricks the victim into clicking it. The victim sends a request to the client's callback URL using the attacker's apparently valid auth code. The client then creates a new session for the victim tied to the attacker's account on the third-party service.
> 
> A `state` parameter is a random value generated by the client application and stored in the victim's session. When the client initiates OAuth, it adds the `state` value to the authorization URL as a query parameter. The third-party authentication service passes the same `state` value back to the client as part of the callback URL. The client compares the `state` value in the callback URL to the value stored in the victim's session. The attacker's malicious link, which includes a *different* `state` value, will cause the request to fail. Because the `state` parameter is random and only known by the client, it is impossible for an attacker to coerce the victim into signing into the attacker's account on the third-party service.

#### 2. Redirect URI Attacks
The article mentions that validating a `redirect_uri` by simply checking the domain or allowing subdomains is a common mistake. Describe a hypothetical scenario where a “leaky” `redirect_uri` validation (e.g., one that allows any path on a valid domain) could be exploited to steal an authorization code.
> In a redirect URI attack, an attacker finds and exploits a weak validation scheme to steal an authorization code from a victim. The attacker can use the client app's vulnerability to trick a third-party service, e.g. GitHub, into sending the victim's authorization code back to a malicious URL on the client app's domain.
>
> The attacker makes a fake link that uses the app's vulnerable redirect URL as the `redirect_uri` in the OAuth flow. When the victim clicks this link, the third-party auth service sends the authorization code to the client app. The client app's open redirect then forwards the victim and the code to the attacker's server. The attacker can then grab the code from the URL and use it to access the victim's data.
>
> The best defense is to require an exact match for the `redirect_uri`, avoiding any wildcards or arbitrary paths.

#### 3. User Experience vs. Security
Adding a third-party login option like “Login with Google” is a significant user experience improvement. However, it also introduces complexity and new potential security risks. Based on the article and your own thoughts, describe one key trade-off a development team must consider when deciding to implement OAuth. (For example, think about the balance between convenience for the user and the responsibility of the application to protect user data).
> Development teams must consider the responsibility they are taking on when offloading authentication to third-party apps. OAuth represents a convenient login flow for users, but it also presents several opportunities for vulnerabilities on the technical implementation side; any slip-ups with regard to the implementation of an OAuth login flow can explose an application to exploitation by experienced bad actors.
>
> In short, teams must become more fastidious, organized, and disciplined in their implementation than bad actors are clever and persistent. It's on the teams and their leadership to decide whether the user convenience OAuth provides for users is worth the time it will take to properly research and implement it on the back-end.
